package ca.gc.cra.fxit.xmlt.task.xml.ftc;

import java.math.BigDecimal;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.List;

import javax.xml.bind.JAXBContext;
import javax.xml.bind.JAXBElement;
import javax.xml.bind.JAXBException;
import javax.xml.bind.Marshaller;
import javax.xml.datatype.DatatypeFactory;
import javax.xml.datatype.XMLGregorianCalendar;
import javax.xml.namespace.QName;

//import org.apache.commons.logging.Log;
//import org.apache.commons.logging.LogFactory;

import org.apache.log4j.Logger;

import org.xml.sax.SAXException;

//import java content classes generated by JAXB XJC binding compiler
// import java classes generated by cob2java
import ca.gc.cra.fxit.xmlt.task.xml.CustomXMLStreamWriter;
import ca.gc.cra.fxit.xmlt.transformation.cob2java.ftc.*;
import ca.gc.cra.fxit.xmlt.transformation.jaxb.ftc.*;

/**
 * JAXBTransformer is used to transform large flat files into International FATCA XML format.
 * JAXBTransformer reads and transforms records one by one and appends the resulting XML to an output FATCA XML file.
 * Characters &<>"' are escaped where necessary in XML element, and attribute values by JAXB and StAX.
 * 
 */
public class JAXBTransformer {
	Logger log =  Logger.getLogger(JAXBTransformer.class);

    /**
     * Maximum number of occurrences of Residence Country Code. Value {@value}.
     * This is the maximum number of occurrences in the input file. The output is unbounded. 
     */
	public static final int MAX_RESIDENCE_COUNTRY_CODES = 5;

    /**
     * Maximum number of occurrences of Controlling Person per Account Report. Value {@value}.
     * This is the maximum number of occurrences of Controlling Person per Account Report in the input file. The output is unbounded. 
     */
	public static final int MAX_CONTROLLING_PERSONS = 16;

	/**
     * Number of digits after the decimal place in account balance and payment amounts. Value {@value}. 
     */
	public static final int MAX_DECIMAL_PLACES = 2;

	/**
	 * If true, use test DocTypeIndic codes. If false, use production codes.
	 * Test codes should ONLY be used to create FATCA XML files to be sent to IRS during system testing periods, 
	 * and not for PRODUCTION files to be sent to IRS. 
	 */
	private boolean useTestDocTypeIndicCodes = false;
    
	/**
     * FATCA Entity Sender ID for Canada. Value {@value}.
     */
	private static final String FATCA_ENTITY_SENDER_ID_CANADA = "000000.00000.TA.124";
	/**
     * Transmitting country code. Use 2-character country code for Canada. Value {@value}.
     */
	private static final String TRANSMITTING_COUNTRY_CODE = "CA";
	/**
     * Receiving country code. Use 2-character country code for United States. Value {@value}.
     */
	private static final String RECEIVING_COUNTRY_CODE = "US";
	
	/**
     * FATCA form type in InfoDec. Value {@value}.
     */
	private static final String FATCA_FORM_TYPE = "31";

	private JAXBTransformerContext transformerContext = new JAXBTransformerContext();
			
	private Marshaller fragmentMarshaller = null;
	
    private final static QName MESSAGE_SPEC_QNAME = new QName("urn:oecd:ties:fatca:v1", "MessageSpec", "ftc");
    private final static QName ACCOUNT_REPORT_QNAME = new QName("urn:oecd:ties:fatca:v1", "AccountReport", "ftc");
    private final static QName REPORTING_FI_QNAME = new QName("urn:oecd:ties:fatca:v1", "ReportingFI", "ftc");
    private final static QName SPONSOR_QNAME = new QName("urn:oecd:ties:fatca:v1", "Sponsor", "ftc");
	

    /**
     * Single JAXBContext instance for JAXBTransformer
     *
     */
    private class JAXBTransformerContext {
        private JAXBContext context = null;

        public JAXBTransformerContext() { }

        public JAXBContext getInstance() throws JAXBException{
            if (context == null) {
            	context = JAXBContext.newInstance(
            			CorrectableOrganisationPartyType.class, 
            			MessageSpecType.class,
            			CorrectableAccountReportType.class);
            }
            return context;
        }
    }
    
    /**
     * Get CrsMarshaller object that will be used to convert a java content tree into XML data.
	 * The JAXB_FRAGMENT property is set. This is necessary to enable marshalling of XML fragments to 
	 * require a fragment of the content tree in memory as opposed to the entire java content tree in memory at once.
	 * 
     * @return
     * @throws JAXBException
     * @throws SAXException
     */
    private Marshaller getFragmentMarshaller() throws JAXBException, SAXException {
    	if (fragmentMarshaller == null) {
		    JAXBContext context = transformerContext.getInstance();
			fragmentMarshaller = context.createMarshaller();
			fragmentMarshaller.setProperty(Marshaller.JAXB_ENCODING, "UTF-8");
			fragmentMarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);
			fragmentMarshaller.setProperty(Marshaller.JAXB_FRAGMENT, Boolean.TRUE);
    	}

	    return fragmentMarshaller;
    }

    private AccountHolderType createAccountHolderFromIP6PRTSL (
    		IP6PRTSL slipRec,
			IP6PRTAC accountHolderRec) {
		
    	AccountHolderType holder = new AccountHolderType();

		PersonPartyType person = null;
		OrganisationPartyType organisation = null;
		
		FatcaAcctHolderTypeEnumType orgAccountHolderTypeEnum = createFatcaAcctHolderTypeEnumFromStr(slipRec.getOaTcd());
		if (orgAccountHolderTypeEnum == null) {
			person = createPersonPartyFromIP6PRTSL(slipRec, accountHolderRec);
		} 
		else {
			organisation = createOrganisationPartyFromIP6PRTSL(slipRec, accountHolderRec);
		}
		// set holder content
		if (person != null) {
			holder.setIndividual(person);
		}
    	if (organisation != null) {
    		holder.setOrganisation(organisation);
   			holder.setAcctHolderType(orgAccountHolderTypeEnum);
    	}
    	
    	return holder;
    }

    private AddressType createAddressFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
		
		AddressType address = new AddressType();
		ObjectFactory factory = new ObjectFactory(); 

		// read address content from input 
		//CountryCodeType countryCode = createCountryCode(input, countryCodeBeginIndex);
		String countryCode = createCountryCodeFromStr(reportingFIRec.getFilrCntryCd());
		String addressFree = createAddressFreeFromStr(reportingFIRec.getFilrAddrFrstTxt(), reportingFIRec.getFilrAddrSecTxt());
		AddressFixType addressFix = createAddressFixFromStr(reportingFIRec.getFilrPstlZipCd(), reportingFIRec.getFilrCtyNm(), reportingFIRec.getFiPvstNm());

		// set address content
		if (countryCode != null) {
			//JAXBElement<CountryCodeType> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			JAXBElement<String> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			address.getContent().add(jaxbCountryCode);
		}
		if (addressFix != null) {
			JAXBElement<AddressFixType> jaxbAddressFix = factory.createAddressTypeAddressFix(addressFix);
			address.getContent().add(jaxbAddressFix);
		}
		if (addressFree != null) {
			JAXBElement<String> jaxbAddressFree = factory.createAddressTypeAddressFree(addressFree);
			address.getContent().add(jaxbAddressFree);
		}

		factory = null;
		
		return address;
    }    
    
    private AddressType createAddressFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
		
		AddressType address = new AddressType();
		ObjectFactory factory = new ObjectFactory(); 

		// read address content from input 
		//CountryCodeType countryCode = createCountryCode(input, countryCodeBeginIndex);
		String countryCode = createCountryCodeFromStr(sponsorRec.getFispCntryCd());
		String addressFree = createAddressFreeFromStr(sponsorRec.getFispAddrL1Txt(), sponsorRec.getFispAddrL2Txt());
		AddressFixType addressFix = createAddressFixFromStr(sponsorRec.getFispPstlZipCd(), sponsorRec.getFispCtyNm(), sponsorRec.getFispPvstNm());

		// set address content
		if (countryCode != null) {
			//JAXBElement<CountryCodeType> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			JAXBElement<String> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			address.getContent().add(jaxbCountryCode);
		}
		if (addressFix != null) {
			JAXBElement<AddressFixType> jaxbAddressFix = factory.createAddressTypeAddressFix(addressFix);
			address.getContent().add(jaxbAddressFix);
		}
		if (addressFree != null) {
			JAXBElement<String> jaxbAddressFree = factory.createAddressTypeAddressFree(addressFree);
			address.getContent().add(jaxbAddressFree);
		}

		factory = null;
		
		return address;
    }    

    private AddressType createAddressFromIP6PRTAC (
    		IP6PRTAC accountHolderRec) {
		
		AddressType address = new AddressType();
		ObjectFactory factory = new ObjectFactory(); 

		// read address content from input 
		//CountryCodeType countryCode = createCountryCode(input, countryCodeBeginIndex);
		String countryCode = createCountryCodeFromStr(accountHolderRec.getFiAhCntryCd());
		String addressFree = createAddressFreeFromStr(accountHolderRec.getFiAhAddrL1Txt(), accountHolderRec.getFiAhAddrL2Txt());
		AddressFixType addressFix = createAddressFixFromStr(accountHolderRec.getFiAhPstlZipCd(), accountHolderRec.getFiAhCtyNm(), accountHolderRec.getFiAhPvstNm());

		// set address content
		if (countryCode != null) {
			//JAXBElement<CountryCodeType> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			JAXBElement<String> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			address.getContent().add(jaxbCountryCode);
		}
		if (addressFix != null) {
			JAXBElement<AddressFixType> jaxbAddressFix = factory.createAddressTypeAddressFix(addressFix);
			address.getContent().add(jaxbAddressFix);
		}
		if (addressFree != null) {
			JAXBElement<String> jaxbAddressFree = factory.createAddressTypeAddressFree(addressFree);
			address.getContent().add(jaxbAddressFree);
		}

		factory = null;
		
		return address;
    }    

    private AddressType createAddressFromIP6PRTCP (
    		IP6PRTCP personRec) {
		
		AddressType address = new AddressType();
		ObjectFactory factory = new ObjectFactory(); 

		// read address content from input 
		//CountryCodeType countryCode = createCountryCode(input, countryCodeBeginIndex);
		String countryCode = createCountryCodeFromStr(personRec.getOaCpCntryCd());
		String addressFree = createAddressFreeFromStr(personRec.getOaCpAddrL1Txt(), personRec.getOaCpAddrL2Txt());
		AddressFixType addressFix = createAddressFixFromStr(personRec.getOaCpPstlZipCd(), personRec.getOaCpCtyNm(), personRec.getOaCpPvstNm());

		// set address content
		if (countryCode != null) {
			//JAXBElement<CountryCodeType> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			JAXBElement<String> jaxbCountryCode = factory.createAddressTypeCountryCode(countryCode);
			address.getContent().add(jaxbCountryCode);
		}
		if (addressFix != null) {
			JAXBElement<AddressFixType> jaxbAddressFix = factory.createAddressTypeAddressFix(addressFix);
			address.getContent().add(jaxbAddressFix);
		}
		if (addressFree != null) {
			JAXBElement<String> jaxbAddressFree = factory.createAddressTypeAddressFree(addressFree);
			address.getContent().add(jaxbAddressFree);
		}

		factory = null;
		
		return address;
    }    

    private AddressFixType createAddressFixFromStr (String postCode, String city, String countrySubEntity) {
		
		AddressFixType addressFix = new AddressFixType();
    	
		// read addressFix content from input 
		String postCodeStr = postCode.trim();
		String cityStr = city.trim();
		String countrySubEntityStr = countrySubEntity.trim();

		// set addressFix content
		if (!postCodeStr.isEmpty()) {
			addressFix.setPostCode(postCodeStr);
		}
		// City is required for schema validation, and can be blank
		addressFix.setCity(cityStr);
		if (!countrySubEntityStr.isEmpty()) {
			addressFix.setCountrySubentity(countrySubEntityStr);
		}

		return addressFix;
    }    

    private String createAddressFreeFromStr (String addressLine1Txt, String addressLine2Txt) {
		
    	// Combine Address Line 1 Text and Address Line 2 Text
    	String line1 = addressLine1Txt.trim();
    	String line2 = addressLine2Txt.trim();
		String addressFreeStr = "";
		if (!line1.isEmpty() && !line2.isEmpty())
			addressFreeStr = line1 + " " + line2;
		else if (!line1.isEmpty())
			addressFreeStr = line1;
		else if (!line2.isEmpty())
			addressFreeStr = line2;
	
		return addressFreeStr;
    }
    
    private List<AddressType> createAddressListFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
    	
    	List<AddressType> addressList = null;
    	
		AddressType address = createAddressFromIP6PRTSM(reportingFIRec);
		if (address != null) {
			addressList = new ArrayList<AddressType>();
			addressList.add(address);
		}
		return addressList;
    }

    private List<AddressType> createAddressListFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
    	
    	List<AddressType> addressList = null;
    	
		AddressType address = createAddressFromIP6PRTSP(sponsorRec);
		if (address != null) {
			addressList = new ArrayList<AddressType>();
			addressList.add(address);
		}
		return addressList;
    }

    private List<AddressType> createAddressListFromIP6PRTAC (
    		IP6PRTAC accountHolderRec) {
    	
    	List<AddressType> addressList = null;
    	
		AddressType address = createAddressFromIP6PRTAC(accountHolderRec);
		if (address != null) {
			addressList = new ArrayList<AddressType>();
			addressList.add(address);
		}
		return addressList;
    }

    private List<AddressType> createAddressListFromIP6PRTCP (
    		IP6PRTCP personRec) {
    	
    	List<AddressType> addressList = null;
    	
		AddressType address = createAddressFromIP6PRTCP(personRec);
		if (address != null) {
			addressList = new ArrayList<AddressType>();
			addressList.add(address);
		}
		return addressList;
    }

    private PersonPartyType.BirthInfo createBirthInfoFromStr (String birthYear, String birthMonth, String birthDay) {
		
    	PersonPartyType.BirthInfo birthInfo = null;
    	
      String birthDateStr = birthYear.trim() + birthMonth.trim()
                   + birthDay.trim();
      if (birthDateStr != null && !birthDateStr.isEmpty()) {
            // parse birth date from input string. Throws ParseException if
            // date cannot be parsed
           
            try {
                   SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd");
                   sdf.setLenient(false);
                   sdf.parse(birthDateStr);
            } catch (ParseException ex) {
 
                   birthDateStr = null;
            }                          
      }
      if (birthDateStr != null && !birthDateStr.isEmpty()) {
            String birthDateXMLStr = birthYear + "-" + birthMonth + "-" + birthDay;
            birthInfo = new PersonPartyType.BirthInfo();
            if (birthInfo != null) {
                   birthInfo.setBirthDate(birthDateXMLStr);
            }
      }
		
		return birthInfo;
    }

    private CorrectableAccountReportType createCorrectableAccountReportFromIP6PRTSL(
			IP6PRTSL slipRec,
			IP6PRTAC accountHolderRec,
			List<IP6PRTCP> personRecs) {
    	
    	// create an empty CorrectableAccountReportType object                                             
    	CorrectableAccountReportType report = new CorrectableAccountReportType();
	    
    	List<PersonPartyType> substantialOwner = null;

		DocSpecType docSpec = createDocSpecFromIP6PRTSL(slipRec);
		String accountNumber = slipRec.getFiCltaNbr().trim();
		AccountHolderType accountHolder = createAccountHolderFromIP6PRTSL(slipRec, accountHolderRec);
	    if (accountHolder != null && accountHolder.getOrganisation() != null) {
	    	substantialOwner = createPersonPartyListFromIP6PRTCP(personRecs);
	    }
	    //CurrCodeType currCode = createCurrCodeFromStr(accountHolderRec.getFiAcctCrcyTcd());
	    String currCode = createCurrCodeFromStr(accountHolderRec.getFiAcctCrcyTcd());
	    MonAmntType accountBalance = createMonAmntFromStr(accountHolderRec.getFiAbamt(), currCode);
	    List<PaymentType> payment = createPaymentListFromIP6PRTAC(accountHolderRec, currCode);

    	if (docSpec != null) {
    		report.setDocSpec(docSpec);
    	}
    	if (accountNumber != null) {
    		report.setAccountNumber(accountNumber);
    	}
    	if (accountHolder != null) {
    		report.setAccountHolder(accountHolder);
    	}
    	if (substantialOwner != null && !substantialOwner.isEmpty()) {
    		report.getSubstantialOwner().addAll(substantialOwner);
    	}
    	if (accountBalance != null) {
    		report.setAccountBalance(accountBalance);
    	}
    	if (payment != null && !payment.isEmpty()) {
    		report.getPayment().addAll(payment);
    	}

		// return it
    	return report;
    }    
    
    private CorrectableOrganisationPartyType createCorrectableOrganisationPartyFromIP6PRTSM(
    		IP6PRTSM reportingFIRec) {
    	
    	// create an empty CorrectableOrganisationPartyType object                                             
    	CorrectableOrganisationPartyType party = new CorrectableOrganisationPartyType();

    	//List<CountryCodeType> resCountryCode = createCountryCodeList(input, resCountryCodeBeginIndex);
    	List<String> resCountryCode = createCountryCodeListFromIP6PRTSM(reportingFIRec);
		List<TINType> tin = createTINListFromIP6PRTSM(reportingFIRec);
		List<NameOrganisationType> name = createNameOrganisationListFromIP6PRTSM(reportingFIRec);
		List<AddressType> address = createAddressListFromIP6PRTSM(reportingFIRec);
		DocSpecType docSpec = createDocSpecFromIP6PRTSM(reportingFIRec);
		
    	if (resCountryCode != null && !resCountryCode.isEmpty()) {
    		party.getResCountryCode().addAll(resCountryCode);
    	}
    	if (tin != null && !tin.isEmpty()) {
    		party.getTIN().addAll(tin);
    	}
		// One or more Name is required for schema validation, and can be blank
    	if (name != null && !name.isEmpty()) {
    		party.getName().addAll(name);
    	}
		// One or more Address is required for schema validation
    	if (address != null && !address.isEmpty()) {
    		party.getAddress().addAll(address);
    	}
    	if (docSpec != null) {
    		party.setDocSpec(docSpec);
    	}

		// return it
    	return party;
    }

    private CorrectableOrganisationPartyType createCorrectableOrganisationPartyFromIP6PRTSP(
    		IP6PRTSP sponsorRec) {
    	
    	// create an empty CorrectableOrganisationPartyType object                                             
    	CorrectableOrganisationPartyType party = new CorrectableOrganisationPartyType();

    	//List<CountryCodeType> resCountryCode = createCountryCodeList(input, resCountryCodeBeginIndex);
    	List<String> resCountryCode = createCountryCodeListFromIP6PRTSP(sponsorRec);
		List<TINType> tin = createTINListFromIP6PRTSP(sponsorRec);
		List<NameOrganisationType> name = createNameOrganisationListFromIP6PRTSP(sponsorRec);
		List<AddressType> address = createAddressListFromIP6PRTSP(sponsorRec);
		DocSpecType docSpec = createDocSpecFromIP6PRTSP(sponsorRec);
		
    	if (resCountryCode != null && !resCountryCode.isEmpty()) {
    		party.getResCountryCode().addAll(resCountryCode);
    	}
    	if (tin != null && !tin.isEmpty()) {
    		party.getTIN().addAll(tin);
    	}
		// One or more Name is required for schema validation, and can be blank
    	if (name != null && !name.isEmpty()) {
    		party.getName().addAll(name);
    	}
		// One or more Address is required for schema validation
    	if (address != null && !address.isEmpty()) {
    		party.getAddress().addAll(address);
    	}
    	if (docSpec != null) {
    		party.setDocSpec(docSpec);
    	}

		// return it
    	return party;
    }
    
    //TODO: Use FATCA schema without customization if possible.
    // A custom FATCA v1.1 schema was created having CountryCodeType replaced with String to allow
    // passing invalid country codes as-is to the XML file, if they exist in the flat file. 
    // In future, if invalid country/currency codes are no longer releaseable errors from InfoDec, then
    // the original schema can be used, and String can be changed back to CountryCodeType.

    //private CountryCodeType createCountryCodeFromStr (
    /**
     * Generates an ISO country code for a specified input String.  If the input does not 
     * correspond to a valid ISO country code then null will be returned. 
     * @param input a string that corresponds 
     * @param isMandatory when true this method will attempt to return a result for an unrecognizable input ;
     * @return a String representation of the ISO country code that corresponds to the specified String.
     */
    private String createCountryCodeFromStr (
    		String input, boolean isMandatory) {
    			
    	//CountryCodeType countryCode = null;
    	String countryCode = null;
    	
		String countryCodeStr = input.toUpperCase().trim();
		
		if (!countryCodeStr.isEmpty()) {
			try {
				 CountryCodeType.fromValue(countryCodeStr);
				 countryCode = countryCodeStr;
			}
			catch (IllegalArgumentException iae) {
				// Optional invalid country codes are omitted from the XML, whereas 
				// mandatory invalid country codes are passed through as-is since the should be corrected in InfoDec
				if (isMandatory) {
					countryCode = countryCodeStr;
				}
			}
		}
		return countryCode;
	}

    /**
     * Generates an ISO country code from the specified String.
     *  
     * @param input
     * @return a String representation of the ISO country code that corresponds to the specified String
     */
    private String createCountryCodeFromStr (String input) {
    	return createCountryCodeFromStr(input, true);
    }

    //private static List<CountryCodeType> createCountryCodeListFromIP6PRTSM (IP6PRTSM reportingFIRec) {
    private List<String> createCountryCodeListFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
    	
    	//List<CountryCodeType> countryCodeList = null;
    	List<String> countryCodeList = null;
    	
    	//CountryCodeType countryCode = createCountryCode(input, beginIndex);
    	String countryCode = createCountryCodeFromStr(reportingFIRec.getFiRsdCntryCd(), false);
		if (countryCode != null) {
			//countryCodeList = new ArrayList<CountryCodeType>();
			countryCodeList = new ArrayList<String>();
			countryCodeList.add(countryCode);
		}
		return countryCodeList;
    }


    private List<String> createCountryCodeListFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
    	
    	//List<CountryCodeType> countryCodeList = null;
    	List<String> countryCodeList = null;
    	
    	//CountryCodeType countryCode = createCountryCode(input, beginIndex);
    	String countryCode = createCountryCodeFromStr(sponsorRec.getFispRsdCntryCd(), false);
		if (countryCode != null) {
			//countryCodeList = new ArrayList<CountryCodeType>();
			countryCodeList = new ArrayList<String>();
			countryCodeList.add(countryCode);
		}
		return countryCodeList;
    }

    private List<String> createPersonResCountryCodeListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
    	//List<CountryCodeType> countryCodeList = null;
    	List<String> countryCodeList = null;
    	
    	for (int i = 0; i < MAX_RESIDENCE_COUNTRY_CODES; i++) {
	    	//CountryCodeType countryCode = createCountryCodeFromStr(slipRec.getFiAhRsdCntryCd(i));
	    	String countryCode = createCountryCodeFromStr(slipRec.getFiAhRsdCntryCd(i), false);
			if (countryCode != null) {
				//countryCodeList = new ArrayList<CountryCodeType>();
				if (countryCodeList == null) {
					countryCodeList = new ArrayList<String>();
				}
				countryCodeList.add(countryCode);
			}
    	}
    	
		return countryCodeList;
    }

    private List<String> createPersonResCountryCodeListFromIP6PRTCP (
    		IP6PRTCP personRec) {
    	
    	//List<CountryCodeType> countryCodeList = null;
    	List<String> countryCodeList = null;
    	
    	for (int i = 0; i < MAX_RESIDENCE_COUNTRY_CODES; i++) {
	    	//CountryCodeType countryCode = createCountryCode(input, beginIndex);
	    	String countryCode = createCountryCodeFromStr(personRec.getOaCpRsdCntryCd(i), false);
			if (countryCode != null) {
				//countryCodeList = new ArrayList<CountryCodeType>();
				if (countryCodeList == null) {
					countryCodeList = new ArrayList<String>();
				}
				countryCodeList.add(countryCode);
			}
    	}
    	
		return countryCodeList;
    }
    
    private List<String> createOrganisationResCountryCodeListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
    	//List<CountryCodeType> countryCodeList = null;
    	List<String> countryCodeList = null;
    	
    	for (int i = 0; i < MAX_RESIDENCE_COUNTRY_CODES; i++) {
	    	//CountryCodeType countryCode = createCountryCode(input, beginIndex);
	    	String countryCode = createCountryCodeFromStr(slipRec.getAhRsdCntryCd(i), false);
			if (countryCode != null) {
				//countryCodeList = new ArrayList<CountryCodeType>();
				if (countryCodeList == null) {
					countryCodeList = new ArrayList<String>();
				}
				countryCodeList.add(countryCode);
			}
    	}
    	
		return countryCodeList;
    }

    //TODO: Use FATCA schema without customization if possible.
    // A customized copy of FATCA v1.1 schema was created having CurrCodeType replaced with String to allow
    // passing invalid currency codes as-is to the XML file, if they exist in the flat file. 
    // In future, if invalid country/currency codes are no longer releaseable errors from InfoDec, then
    // the original schema can be used, and String can be changed back to CurrCodeType.
    
    // Temporary fix:
    // - convert all valid lowercase currency codes to uppercase
    // - replace 'CAN' with 'CAD
    // - replace invalid currency codes with 'XXX'
    
    //private CurrCodeType createCurrCodeFromStr (
    private String createCurrCodeFromStr (
    		String input) {
		
    	//CurrCodeType currCode = null;
    	String currCode = null;
    	
    	String currCodeStr = input.trim();
		if (!currCodeStr.isEmpty()) {
			currCodeStr = currCodeStr.toUpperCase();
			//currCode = CurrCodeType.fromValue(currCodeStr);
			if(currCodeStr.equals("CAN")) {
				currCode = CurrCodeType.CAD.value();
			} else {
				try {
					CurrCodeType curr = CurrCodeType.fromValue(currCodeStr);
					currCode = curr.value();
				} catch (IllegalArgumentException ex) {
					currCode = CurrCodeType.XXX.value();
				}
			}
		}
		else {
			currCode = CurrCodeType.XXX.value();
		}
			
		return currCode;
	}
    
    private DocSpecType createDocSpecFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
		
		DocSpecType docSpec = new DocSpecType();

		// read docSpec content from input 
		FatcaDocTypeIndicEnumType docTypeIndicEnum = createFatcaDocTypeIndicEnumFromStr(reportingFIRec.getFiInfoDtyCd());
		String docRefIdStr = reportingFIRec.getFiDocRefId().trim();
		String corrDocRefIdStr = reportingFIRec.getFiCorrDocRefId().trim();

		// set docSpec content
		if (docTypeIndicEnum != null) {
			docSpec.setDocTypeIndic(docTypeIndicEnum);
		}
		docSpec.setDocRefId(docRefIdStr);
		if (!corrDocRefIdStr.isEmpty()) {
			docSpec.setCorrDocRefId(corrDocRefIdStr);
		}
		
		return docSpec;
    }    

    private DocSpecType createDocSpecFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
		
		DocSpecType docSpec = new DocSpecType();

		// read docSpec content from input 
		FatcaDocTypeIndicEnumType docTypeIndicEnum = createFatcaDocTypeIndicEnumFromStr(sponsorRec.getFispInfoDtyCd());
		String docRefIdStr = sponsorRec.getFispDocRefId().trim();
		String corrDocRefIdStr = sponsorRec.getFispCorrDocRefId().trim();

		// set docSpec content
		if (docTypeIndicEnum != null) {
			docSpec.setDocTypeIndic(docTypeIndicEnum);
		}
		docSpec.setDocRefId(docRefIdStr);
		if (!corrDocRefIdStr.isEmpty()) {
			docSpec.setCorrDocRefId(corrDocRefIdStr);
		}
		
		return docSpec;
    }    

    private DocSpecType createDocSpecFromIP6PRTSL (
    		IP6PRTSL slipRec) {
		
		DocSpecType docSpec = new DocSpecType();

		// read docSpec content from input 
		FatcaDocTypeIndicEnumType docTypeIndicEnum = createFatcaDocTypeIndicEnumFromStr(slipRec.getIfaieRtnSlpDtyCd());
		String docRefIdStr = slipRec.getIfaieSlpDocRefId().trim();
		String corrDocRefIdStr = slipRec.getIfaieSlpCorrDocId().trim();

		// set docSpec content
		if (docTypeIndicEnum != null) {
			docSpec.setDocTypeIndic(docTypeIndicEnum);
		}
		docSpec.setDocRefId(docRefIdStr);
		if (!corrDocRefIdStr.isEmpty()) {
			docSpec.setCorrDocRefId(corrDocRefIdStr);
		}
		
		return docSpec;
    }    

    private FatcaDocTypeIndicEnumType createFatcaDocTypeIndicEnumFromStr (
    		String input) {
		
    	FatcaDocTypeIndicEnumType docTypeIndicEnum = null;
    	
		String docTypeIndicEnumStr = input.trim();
		if (!docTypeIndicEnumStr.isEmpty()) {
			if (isUseTestDocTypeIndicCodes()) {
				switch (Character.toUpperCase(docTypeIndicEnumStr.charAt(0))) {
				case 'O' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_11; // new data (original)
							break;
				case 'C' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_13; // void data (cancel)
							break;
				case 'A' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_14; // amended data (amendment)
							break;
				default : 	break;
				}
			}
			else {
				switch (Character.toUpperCase(docTypeIndicEnumStr.charAt(0))) {
				case 'O' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_1; // new data (original)
							break;
				case 'C' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_3; // void data (cancel)
							break;
				case 'A' : 	docTypeIndicEnum = FatcaDocTypeIndicEnumType.FATCA_4; // amended data (amendment)
							break;
				default : 	break;
				}
			}
		}
		return docTypeIndicEnum;
	}
    
    private FatcaAcctHolderTypeEnumType createFatcaAcctHolderTypeEnumFromStr (
    		String input) {
		
    	FatcaAcctHolderTypeEnumType acctHolderTypeEnum = null;
    	
		String acctHolderTypeEnumStr = input.trim();
		if (acctHolderTypeEnumStr.equals("01")) {
			acctHolderTypeEnum = FatcaAcctHolderTypeEnumType.FATCA_101;
		}
		else if (acctHolderTypeEnumStr.equals("02")) {
			acctHolderTypeEnum = FatcaAcctHolderTypeEnumType.FATCA_102;
		}
		else if (acctHolderTypeEnumStr.equals("03")) {
			acctHolderTypeEnum = FatcaAcctHolderTypeEnumType.FATCA_103;
		}
		else if (acctHolderTypeEnumStr.equals("04")) {
			acctHolderTypeEnum = FatcaAcctHolderTypeEnumType.FATCA_104;
		}

		return acctHolderTypeEnum;
	}

    private MessageSpecType createMessageSpec(  
            String sendingCompanyIN,
            //CountryCodeType transmittingCountry,
            String transmittingCountry,
            //CountryCodeType receivingCountry,
            String receivingCountry,
            MessageTypeEnumType messageType,
            String warning,
            String contact,
            String messageRefId,
            List<String> corrMessageRefId,
            XMLGregorianCalendar reportingPeriod,
            XMLGregorianCalendar timestamp) {

    	// create an empty MessageSpecType object                                             
    	MessageSpecType messageSpec = new MessageSpecType();
		
		// set properties on it
    	messageSpec.setSendingCompanyIN(sendingCompanyIN);
    	messageSpec.setTransmittingCountry(transmittingCountry);
    	messageSpec.setReceivingCountry(receivingCountry);
    	messageSpec.setMessageType(messageType);
    	messageSpec.setWarning(warning.trim());
    	messageSpec.setContact(contact.trim());
    	messageSpec.setMessageRefId(messageRefId);
    	if (corrMessageRefId != null && corrMessageRefId.isEmpty() == false) {
    		messageSpec.getCorrMessageRefId().addAll(corrMessageRefId);
    	}
    	messageSpec.setReportingPeriod(reportingPeriod);
    	messageSpec.setTimestamp(timestamp);
    	
		// return it
		return messageSpec;
    }


    private MessageTypeEnumType createMessageTypeEnumFromStr (
    		String input) {
		
    	MessageTypeEnumType messageTypeEnum = null;
    	
		String messageTypeEnumStr = input.trim();
		if (!messageTypeEnumStr.isEmpty()) {
			if (messageTypeEnumStr.equalsIgnoreCase(FATCA_FORM_TYPE)) {
				messageTypeEnum = MessageTypeEnumType.FATCA; // FATCA message type
			}
		}
		return messageTypeEnum;
	}

    private String createReportingPeriodFromStr (
    		String input) {
		
    	String reportingPeriod = null;
    	
		String taxationYearStr = input.trim();
		if (!taxationYearStr.isEmpty()) {
			// reporting period is the end of the year to which the data relates in the format YYYY-MM-DD
			reportingPeriod = taxationYearStr + "-12-31";  
		}
		return reportingPeriod;
	}

    //private MonAmntType createMonAmntFromStr (String amount, CurrCodeType currCode) {
    private MonAmntType createMonAmntFromStr (
    		String amount,
    		String currCode) {
		
    	MonAmntType monAmnt = null;
    	
    	if (amount != null) {
	    	int len = amount.length();
	    	String amountWithDecimal = amount.substring(0, len-MAX_DECIMAL_PLACES) + "." + amount.substring(len-MAX_DECIMAL_PLACES);
			// create MonAmnt, and set content of MonAmnt
	    	monAmnt = new MonAmntType();
			BigDecimal value = new BigDecimal(amountWithDecimal);
			monAmnt.setValue(value);
			if (currCode != null) {
				monAmnt.setCurrCode(currCode);
			}
    	}

		return monAmnt;
    }

    private List<NameOrganisationType> createNameOrganisationListFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
    	
		// One or more name is required for schema validation, and can be blank
    	List<NameOrganisationType> nameList = new ArrayList<NameOrganisationType>();
   		NameOrganisationType name = createNameOrganisationFromStr(reportingFIRec.getFilrNmFrstTxt(), reportingFIRec.getFilrNmSecTxt());
    	if (name != null) {
        	nameList.add(name);
    	}
    	
		return nameList;
    }

    private List<NameOrganisationType> createNameOrganisationListFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
    	
		// One or more name is required for schema validation, and can be blank
    	List<NameOrganisationType> nameList = new ArrayList<NameOrganisationType>();
   		NameOrganisationType name = createNameOrganisationFromStr(sponsorRec.getFispNmL1Txt(), sponsorRec.getFispNmL2Txt());
    	if (name != null) {
        	nameList.add(name);
    	}
    	
		return nameList;
    }

    private List<NameOrganisationType> createNameOrganisationListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
		// One or more name is required for schema validation, and can be blank
    	List<NameOrganisationType> nameList = new ArrayList<NameOrganisationType>();
   		NameOrganisationType name = createNameOrganisationFromStr( slipRec.getOaNmL1Txt(), slipRec.getOaNmL2Txt());
    	if (name != null) {
        	nameList.add(name);
    	}
    	
		return nameList;
    }

    private NameOrganisationType createNameOrganisationFromStr (
    		String nameLine1Txt, String nameLine2Txt) {
		
    	NameOrganisationType name = new NameOrganisationType();
    	
    	// Combine Name Line 1 Text and Name Line 2 Text
		String name1 = nameLine1Txt.trim();
		String name2 = nameLine2Txt.trim();
		String nameStr = "";
		if (!name1.isEmpty() && !name2.isEmpty())
			nameStr = name1 + " " + name2;
		else if (!name1.isEmpty())
			nameStr = name1;
		else if (!name2.isEmpty())
			nameStr = name2;
		
		name.setValue(nameStr);

		return name;
    }


    private List<NamePersonType> createNamePersonListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
    	List<NamePersonType> nameList = null;
    	
    	NamePersonType name = createNamePersonFromStr(slipRec.getIndvAhGvnNm(), slipRec.getIndvAhMidNm(), slipRec.getIndvAhSnm());

		if (name != null) {
			nameList = new ArrayList<NamePersonType>();
			nameList.add(name);
		}
		return nameList;
    }
    
    private List<NamePersonType> createNamePersonListFromIP6PRTCP (
    		IP6PRTCP personRec) {
    	
    	List<NamePersonType> nameList = null;
    	
    	NamePersonType name = createNamePersonFromStr(personRec.getOaCpGvnNm(), personRec.getOaCpMidNm(), personRec.getOaCpSnm());
		if (name != null) {
			nameList = new ArrayList<NamePersonType>();
			nameList.add(name);
		}
		return nameList;
    }

    private NamePersonType createNamePersonFromStr (String firstName, String middleName, String lastName) {
		
    	NamePersonType name = new NamePersonType();

		String firstNameStr = firstName.trim();
		String middleNameStr = middleName.trim();
		String lastNameStr = lastName.trim();
		
		// first name is required for schema validation, and can be blank
		NamePersonType.FirstName first = new NamePersonType.FirstName();
		first.setValue(firstNameStr);
		name.setFirstName(first);
		
		// middeName is optional
		if (!middleNameStr.isEmpty()) {
			NamePersonType.MiddleName middle = new NamePersonType.MiddleName();
			middle.setValue(middleNameStr);
			name.getMiddleName().add(middle);
		}
		
		// last name is required for schema validation, and can be blank
		NamePersonType.LastName last = new NamePersonType.LastName();
		last.setValue(lastNameStr);
		name.setLastName(last);

		return name;
    }
    
    private OrganisationPartyType createOrganisationPartyFromIP6PRTSL(
    		IP6PRTSL slipRec,
			IP6PRTAC accountHolderRec) {
		
    	OrganisationPartyType organisation = new OrganisationPartyType();

    	//List<CountryCodeType> resCountryCode = createCountryCodeList(input, resCountryCodeBeginIndex);
    	List<String> resCountryCode = createOrganisationResCountryCodeListFromIP6PRTSL(slipRec);
		List<TINType> tin = createOrganisationTINListFromIP6PRTSL(slipRec);
		List<NameOrganisationType> name = createNameOrganisationListFromIP6PRTSL(slipRec);
		List<AddressType> address = createAddressListFromIP6PRTAC(accountHolderRec);
		
    	if (resCountryCode != null && !resCountryCode.isEmpty()) {
    		organisation.getResCountryCode().addAll(resCountryCode);
    	}
    	if (tin != null && !tin.isEmpty()) {
    		organisation.getTIN().addAll(tin);
    	}
		// One or more Name is required for schema validation, and can be blank
    	if (name != null && !name.isEmpty()) {
    		organisation.getName().addAll(name);
    	}
		// One or more Address is required for schema validation
    	if (address != null && !address.isEmpty()) {
    		organisation.getAddress().addAll(address);
    	}		
    	
    	return organisation;
    }    

    //private List<PaymentType> createPaymentListFromIP6PRTAC (IP6PRTAC accountHolderRec, CurrCodeType currCode) {
    private List<PaymentType> createPaymentListFromIP6PRTAC (
    		IP6PRTAC accountHolderRec,
    		String currCode) {
		
		List<PaymentType> paymentList = null;

    	for (FatcaPaymentTypeEnumType paymentType : FatcaPaymentTypeEnumType.values()) {
    		String amount = null;
    		switch (paymentType) {
    		case FATCA_501 : 
    			amount = accountHolderRec.getFiAhDvamt();
    			break;
			case FATCA_502 : 
				amount = accountHolderRec.getFiAhIntamt();
				break;
    		case FATCA_503 : 
    			amount = accountHolderRec.getFiAhGpramt();
    			break;
			case FATCA_504 : 
				amount = accountHolderRec.getFiAhOamt();
				break;
			default : break;
			}
    		
        	PaymentType payment = createPaymentFromStr(amount, paymentType, currCode);
        	if (payment != null) {
	    		if (paymentList == null) {
	    			paymentList = new ArrayList<PaymentType>();
	    		}
	    		paymentList.add(payment);
    		}
  		}

    	return paymentList;
    }

    //private PaymentType createPaymentFromStr (String amount, FatcaPaymentTypeEnumType paymentType, CurrCodeType currCode) {
    private PaymentType createPaymentFromStr (
    		String amount,
    		FatcaPaymentTypeEnumType paymentType,
    		String currCode) {
		
    	PaymentType payment = null;

		// create MonAmnt, and set content of MonAmnt
		if (amount != null && !amount.isEmpty() && new BigDecimal(amount).compareTo(BigDecimal.ZERO) != 0) {
			MonAmntType paymentAmnt = createMonAmntFromStr(amount, currCode);
			payment = new PaymentType();
			if (payment != null) {
				payment.setType(paymentType);
				payment.setPaymentAmnt(paymentAmnt);
			}
		}
		
		return payment;
    }

    private List<PersonPartyType> createPersonPartyListFromIP6PRTCP (
    		List<IP6PRTCP> personRecs) {
    	
    	List<PersonPartyType> personList = null;

    	if (personRecs != null) {
	    	for (IP6PRTCP personRec : personRecs) {
	    		PersonPartyType person = createPersonPartyFromIP6PRTCP(personRec);
	    		if (person != null) {
		    		if (personList == null) {
		    			personList = new ArrayList<PersonPartyType>();
		    		}
		    		personList.add(person);
	    		}
	    	}
    	}
    	
		return personList;
    }
    
    private PersonPartyType createPersonPartyFromIP6PRTSL(
    		IP6PRTSL slipRec,
			IP6PRTAC accountHolderRec) {
		
    	PersonPartyType person = new PersonPartyType();

    	//List<CountryCodeType> resCountryCode = createCountryCodeList(input, resCountryCodeBeginIndex);
    	List<String> resCountryCode = createPersonResCountryCodeListFromIP6PRTSL(slipRec);
		List<TINType> tin = createPersonTINListFromIP6PRTSL(slipRec);
		List<NamePersonType> name = createNamePersonListFromIP6PRTSL(slipRec);
		List<AddressType> address = createAddressListFromIP6PRTAC(accountHolderRec);
		PersonPartyType.BirthInfo birthInfo = createBirthInfoFromStr(slipRec.getIndvAhBrthYr(), slipRec.getIndvAhBrthMo(), slipRec.getIndvAhBrthDy());

    	if (resCountryCode != null && !resCountryCode.isEmpty()) {
    		person.getResCountryCode().addAll(resCountryCode);
    	}
    	if (tin != null && !tin.isEmpty()) {
    		person.getTIN().addAll(tin);
    	}
		// One or more Name is required for schema validation, and can be blank
    	if (name != null && !name.isEmpty()) {
    		person.getName().addAll(name);
    	}
		// One or more Address is required for schema validation
    	if (address != null && !address.isEmpty()) {
    		person.getAddress().addAll(address);
    	}
    	if (birthInfo != null) {
    		person.setBirthInfo(birthInfo);
    	}
    	return person;
    }    

    private PersonPartyType createPersonPartyFromIP6PRTCP(
    		IP6PRTCP personRec) {
		
    	PersonPartyType person = new PersonPartyType();

    	//List<CountryCodeType> resCountryCode = createCountryCodeList(input, resCountryCodeBeginIndex);
    	List<String> resCountryCode = createPersonResCountryCodeListFromIP6PRTCP(personRec);
		List<TINType> tin = createPersonTINListFromIP6PRTCP(personRec);
		List<NamePersonType> name = createNamePersonListFromIP6PRTCP(personRec);
		List<AddressType> address = createAddressListFromIP6PRTCP(personRec);
		PersonPartyType.BirthInfo birthInfo = createBirthInfoFromStr(personRec.getOaCpBrthYr(), personRec.getOaCpBrthMo(), personRec.getOaCpBrthDy());

    	if (resCountryCode != null && !resCountryCode.isEmpty()) {
    		person.getResCountryCode().addAll(resCountryCode);
    	}
    	if (tin != null && !tin.isEmpty()) {
    		person.getTIN().addAll(tin);
    	}
		// One or more Name is required for schema validation, and can be blank
    	if (name != null && !name.isEmpty()) {
    		person.getName().addAll(name);
    	}
		// One or more Address is required for schema validation
    	if (address != null && !address.isEmpty()) {
    		person.getAddress().addAll(address);
    	}
    	if (birthInfo != null) {
    		person.setBirthInfo(birthInfo);
    	}
    	return person;
    }    

    private TINType createTINFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
		
		TINType tin = null;

		// read TIN element value from input
		String tinStr = reportingFIRec.getFiGiin().trim();

		// create TIN, and set content of TIN
		if (!tinStr.isEmpty()) {
			tin = new TINType();
			tin.setValue(tinStr);
		}
		return tin;
    }

    private TINType createTINFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
		
		TINType tin = null;

		// read TIN element value from input
		String tinStr = sponsorRec.getFispGiin().trim();

		// create TIN, and set content of TIN
		if (!tinStr.isEmpty()) {
			tin = new TINType();
			tin.setValue(tinStr);
		}
		return tin;
    }

    private TINType createPersonTINFromIP6PRTSL (
    		IP6PRTSL slipRec) {
		
		TINType tin = null;

		// read TIN element value from input
		String tinStr = slipRec.getIndvAhFgnTin().trim();

		//CountryCodeType issuedBy = createCountryCodeFromStr(slipRec.getIndvAhFtinCntryCd());
		String issuedBy = createCountryCodeFromStr(slipRec.getIndvAhFtinCntryCd(), false);

		// create TIN, and set content of TIN
		if (!tinStr.isEmpty()) {
			tin = new TINType();
			tin.setValue(tinStr);
			if (issuedBy != null) {
				tin.setIssuedBy(issuedBy);
			}
		}
		return tin;
    }

    private TINType createPersonTINFromIP6PRTCP (
    		IP6PRTCP personRec) {
		
		TINType tin = null;

		// read TIN element value from input
		String tinStr = personRec.getOaCpFgnTin().trim();

		//CountryCodeType issuedBy = createCountryCodeFromStr(slipRec.getIndvAhFtinCntryCd());
		String issuedBy = createCountryCodeFromStr(personRec.getOaCpFgnTinCntryCd(), false);

		// create TIN, and set content of TIN
		if (!tinStr.isEmpty()) {
			tin = new TINType();
			tin.setValue(tinStr);
			if (issuedBy != null) {
				tin.setIssuedBy(issuedBy);
			}
		}
		return tin;
    }

    private TINType createOrganisationTINFromIP6PRTSL (
    		IP6PRTSL slipRec) {
		
		TINType tin = null;

		// read TIN element value from input
		String tinStr = slipRec.getOaFgnTin().trim();

		//CountryCodeType issuedBy = createCountryCodeFromStr(slipRec.getIndvAhFtinCntryCd());
		String issuedBy = createCountryCodeFromStr(slipRec.getOaFgnTinCntryCd(), false);

		// create TIN, and set content of TIN
		if (!tinStr.isEmpty()) {
			tin = new TINType();
			tin.setValue(tinStr);
			if (issuedBy != null) {
				tin.setIssuedBy(issuedBy);
			}
		}
		return tin;
    }

    private List<TINType> createTINListFromIP6PRTSM (
    		IP6PRTSM reportingFIRec) {
    	
    	List<TINType> tinList = null;
    	
    	TINType tin = createTINFromIP6PRTSM(reportingFIRec);
		if (tin != null) {
			tinList = new ArrayList<TINType>();
			tinList.add(tin);
		}
		return tinList;
    }

    private List<TINType> createTINListFromIP6PRTSP (
    		IP6PRTSP sponsorRec) {
    	
    	List<TINType> tinList = null;
    	
    	TINType tin = createTINFromIP6PRTSP(sponsorRec);
		if (tin != null) {
			tinList = new ArrayList<TINType>();
			tinList.add(tin);
		}
		return tinList;
    }

    private List<TINType> createPersonTINListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
    	List<TINType> tinList = null;
    	
    	TINType tin = createPersonTINFromIP6PRTSL(slipRec);
		if (tin != null) {
			tinList = new ArrayList<TINType>();
			tinList.add(tin);
		}
		return tinList;
    }

    private List<TINType> createPersonTINListFromIP6PRTCP (
    		IP6PRTCP personRec) {
    	
    	List<TINType> tinList = null;
    	
    	TINType tin = createPersonTINFromIP6PRTCP(personRec);
		if (tin != null) {
			tinList = new ArrayList<TINType>();
			tinList.add(tin);
		}
		return tinList;
    }

    private List<TINType> createOrganisationTINListFromIP6PRTSL (
    		IP6PRTSL slipRec) {
    	
    	List<TINType> tinList = null;
    	
    	TINType tin = createOrganisationTINFromIP6PRTSL(slipRec);
		if (tin != null) {
			tinList = new ArrayList<TINType>();
			tinList.add(tin);
		}
		return tinList;
    }

	/**
	 * This method will perform the transformation of IP6PRTSM to CorrectableOrganisationParty record.
	 *
	 * @param reportingFIRec	input is read from this record
	 * @param writer 			the output is written to this writer
	 * @throws BridgeException
	 */
	private void transformIP6PRTSMCorrectableOrganisationParty(
			IP6PRTSM reportingFIRec, 
			CustomXMLStreamWriter writer) throws Exception {

		try {
			CorrectableOrganisationPartyType party = createCorrectableOrganisationPartyFromIP6PRTSM(reportingFIRec);
			
			Marshaller marshaller = getFragmentMarshaller();
	        marshaller.marshal(new JAXBElement<CorrectableOrganisationPartyType>(
	        		REPORTING_FI_QNAME,
	        		CorrectableOrganisationPartyType.class, party), writer);
	        
		} catch (Throwable e) {
			log.info("FI DocRefId= " + reportingFIRec.getFiDocRefId());
			throw new Exception( e);
		} 
	}
	
	/**
	 * This method will perform the transformation of IP6PRTSP to CorrectableOrganisationParty record.
	 *
	 * @param sponsorRec		input is read from this record
	 * @param writer 			the output is written to this writer
	 * @throws BridgeException
	 */
	private void transformIP6PRTSPCorrectableOrganisationParty(
			IP6PRTSP sponsorRec, 
			CustomXMLStreamWriter writer) throws Exception {

		try {
			CorrectableOrganisationPartyType party = createCorrectableOrganisationPartyFromIP6PRTSP(sponsorRec);
			
			Marshaller marshaller = getFragmentMarshaller();
	        marshaller.marshal(new JAXBElement<CorrectableOrganisationPartyType>(
	        		SPONSOR_QNAME,
	        		CorrectableOrganisationPartyType.class, party), writer);

		} catch (Throwable e) {
			log.info("Sponsor DocRefId= " + sponsorRec.getFispDocRefId());
			throw new Exception(e);
		} 
	}
	
	/**
	 * This method will perform the transformation of an AccountReport record.
	 *
	 * @param recordType	AccountReport record
	 * @param input			input is read from this string
	 * @param beginIndex 	starting position of record in input line
	 * @param writer		the output is written to this writer
	 * @throws BridgeException
	 */
	private void transformIP6PRTSLCorrectableAccountReport(
			IP6PRTSL slipRec,
			IP6PRTAC accountHolderRec,
			List<IP6PRTCP> personRecs,
			CustomXMLStreamWriter writer) throws Exception {

		try {
			CorrectableAccountReportType report = createCorrectableAccountReportFromIP6PRTSL(slipRec, accountHolderRec, personRecs);
			
			Marshaller marshaller = getFragmentMarshaller();
	        marshaller.marshal(new JAXBElement<CorrectableAccountReportType>(
	        		ACCOUNT_REPORT_QNAME,
	        		CorrectableAccountReportType.class, report), writer);
	        
		} catch (Throwable e) {
			log.info("Slip DocRefId= " + slipRec.getIfaieSlpDocRefId());
			throw new Exception( e);
		} 
	}
	
	public boolean isUseTestDocTypeIndicCodes() {
		return useTestDocTypeIndicCodes;
	}

	public void setUseTestDocTypeIndicCodes(boolean useTestCodes) {
		useTestDocTypeIndicCodes = useTestCodes;
	}

	/**
	 * This method will perform the transformation of all of the following into one XML AccountReport: 
	 * one SLIP, one ACCOUNT HOLDER, and zero or more CONTROLLING PERSON records.
	 * 
	 * @param slipRec
	 * @param accountHolderRec
	 * @param personRecs
	 * @param writer	the output is written to this writer
	 * @throws BridgeException
	 */
	public void transformAccountReport(
			IP6PRTSL slipRec, 
			IP6PRTAC accountHolderRec, 
			List<IP6PRTCP> personRecs,
			CustomXMLStreamWriter writer) throws Exception {

		transformIP6PRTSLCorrectableAccountReport(slipRec, accountHolderRec, personRecs, writer);
	}

	/**
	 * This method will perform the transformation of the input parameters into one XML MessageSpec.  
	 *
	 * @param reportingFIRec
	 * @param warning
	 * @param contact
	 * @param messageRefId
	 * @param corrMessageRefId
	 * @param timestamp
	 * @param writer
	 * @throws BridgeException
	 */
	public void transformMessageSpec(
			IP6PRTSM reportingFIRec,
            String warning,
            String contact,
            String messageRefId,
            List<String> corrMessageRefId,
            String timestamp, 
            CustomXMLStreamWriter writer) throws Exception {

		try {
			
			String sendingCompanyIN = FATCA_ENTITY_SENDER_ID_CANADA;
	    	//CountryCodeType transmittingCountryCode = createCountryCodeFromStr(TRANSMITTING_COUNTRY_CODE);
	    	String transmittingCountryCode = createCountryCodeFromStr(TRANSMITTING_COUNTRY_CODE);

	    	// TODO: Interim solution to hard-code value "US" for ReceivingCountry until recipient country code is validated in InfoDec. 
			// RtnRcpntCntryCd is currently not validated in InfoDec, and can be any 2 characters. 
	    	//CountryCodeType receivingCountryCode = createCountryCodeFromStr(/* reportingFIRec.getRtnRcpntCntryCd() */  RECEIVING_COUNTRY_CODE);
	    	String receivingCountryCode = createCountryCodeFromStr(/* reportingFIRec.getRtnRcpntCntryCd() */ RECEIVING_COUNTRY_CODE);
	    	MessageTypeEnumType messageTypeEnum = createMessageTypeEnumFromStr(reportingFIRec.getRtnTcd());
	    	String reportingPeriod = createReportingPeriodFromStr(reportingFIRec.getRtnTxYr());
	    	XMLGregorianCalendar reportingPeriodXML = DatatypeFactory.newInstance().newXMLGregorianCalendar(reportingPeriod); 
	        XMLGregorianCalendar xmlCreationTimestamp =  DatatypeFactory.newInstance().newXMLGregorianCalendar(timestamp);
		
	    	MessageSpecType messageSpec = createMessageSpec(
	    			sendingCompanyIN, 
	    			transmittingCountryCode, 
	    			receivingCountryCode, 
	    			messageTypeEnum, 
	    			warning, 
	    			contact, 
	    			messageRefId, 
	    			corrMessageRefId, 
	    			reportingPeriodXML, 
	    			xmlCreationTimestamp);
			
			Marshaller marshaller = getFragmentMarshaller();
	        marshaller.marshal(new JAXBElement<MessageSpecType>(
	        		MESSAGE_SPEC_QNAME,
	        		MessageSpecType.class, messageSpec), writer);

		} catch (Throwable e) {
			throw new Exception( e);
		} 
	}

	/**
	 * This method will perform the transformation of one SUMMARY record into one XML ReportingFI.
	 * 
	 * @param reportingFIRec	input is read from this record
	 * @param writer			the output is written to this writer
	 * @throws BridgeException
	 */
	public void transformReportingFI(
			IP6PRTSM reportingFIRec, 
			CustomXMLStreamWriter writer) throws Exception {
		
		transformIP6PRTSMCorrectableOrganisationParty(reportingFIRec, writer);
	}

	/**
	 * This method will perform the transformation of one SPONSOR record into one XML Sponsor.
	 * 
	 * @param sponsorRec	input is read from this record
	 * @param writer		the output is written to this writer
	 * @throws BridgeException
	 */
	public void transformSponsor(
			IP6PRTSP sponsorRec, 
			CustomXMLStreamWriter writer) throws Exception {

		transformIP6PRTSPCorrectableOrganisationParty(sponsorRec, writer);
	}

}

