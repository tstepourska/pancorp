package ca.gc.cra.fxit.xmlt.task;

import java.rmi.RemoteException;
import java.sql.SQLException;
import java.util.IllegalFormatException;

import org.apache.log4j.Logger;

//import ca.gc.cra.db.framework.exceptions.DataException;
//import ca.gc.cra.fxit.ca2us.batch.BridgeException;
//import ca.gc.cra.fxit.ca2us.data.RetrieveFxmtDataInterface;
//import ca.gc.cra.fxit.ca2us.integration.cobol.IP6PRTHD;
//import ca.gc.cra.fxit.xmlt.exception.TaskException;
//import ca.gc.cra.fxit.xmlt.task.compression.CompressionHelper;
import ca.gc.cra.fxit.xmlt.exception.InvalidMessageRefIdException;
import ca.gc.cra.fxit.xmlt.model.PackageInfo;
import ca.gc.cra.fxit.xmlt.transformation.jaxb.crs.CountryCodeType;
import ca.gc.cra.fxit.xmlt.util.Constants;
import ca.gc.cra.fxit.xmlt.util.Utils;

public class GenerateMessageRefId extends AbstractTask {
	private static Logger lg = Logger.getLogger(GenerateMessageRefId.class);
	
	@Override
	public GenerateMessageRefId cloneTask(){
		GenerateMessageRefId t = new GenerateMessageRefId();
		t.setResultCode(this.resultCode);
		t.setResultMessage(this.resultMessage);
		t.setId(this.id);
		t.setSequence(this.sequence);
		t.setJobId(this.jobId);
	
		return t;
	}
	
	@Override
	protected final int invoke(PackageInfo p) {
		lg.debug("GenerateMessageRefID executing");
		int status = Constants.STATUS_CODE_INCOMPLETE;
		String messageRefId = null;
		
		try {
			messageRefId = p.getMessageRefId();
			if(messageRefId==null){
				messageRefId = generateMessageRefID(p);
			}
			lg.info("messageRefId: " + messageRefId);
			
			validateMessageRefId(p);
			
				
		}
		catch(InvalidMessageRefIdException e){
			status = Constants.STATUS_CODE_INVALID_MESSAGE_REF_ID;
		}
		catch(SQLException sqle){
			status = Constants.STATUS_CODE_ERROR;
			lg.error("SQL Error: " + sqle.getErrorCode());
			Utils.logError(lg, sqle);
		}
		catch(Exception e){
			status = Constants.STATUS_CODE_ERROR;
			Utils.logError(lg, e);
		}
		
		//for wireframe testing only - to comment out!
		//status = Constants.STATUS_CODE_SUCCESS;
		// end of to comment out
		
		return status;	
	}
	
	private String generateMessageRefID(PackageInfo p) throws SQLException, Exception {
		String fp = "generateMessageRefID:";
		lg.debug("Begin" + fp);
				
		//messageRefId is generated by the data provider, and has been set earlier
		String messageRefId = p.getMessageRefId();
		if(messageRefId!=null)
			return messageRefId;
				
		//RetrieveFxmtDataInterface fxmtDataBean;
			
		// TODO: Interim solution to hard-code value "US" until recipient country code is validated in InfoDec. 
		// RtnRcpntCntryCd is currently not validated in InfoDec, and can be any 2 characters.
				
		//messageRefID = fxmtDataBean.getNextMessageRefID(TRANSMITTING_COUNTRY_CODE, RECEIVING_COUNTRY_CODE, headerRec.getRtnTxYr());
		messageRefId = "CA2016FR123456789";
		if(lg.isDebugEnabled())
		lg.debug(fp + "messageRefID: " + messageRefId);
		p.setMessageRefId(messageRefId);

		return messageRefId;
	}
	
	private void validateMessageRefId(PackageInfo p) throws InvalidMessageRefIdException {
		String fp = "validateMessageRefID:";
		//boolean valid = false;
		//Metadata senderFileId:
		//<CountryCd Sender>_<CountryCd Receiver>_<Communication_type>_MessageRefID
		try {
		String s = p.getMessageRefId();
		String[] arr = s.split("_");
		String cSender = arr[0];
		String cReceiver = arr[1];
		String commType = arr[2];
		String messRefId = arr[3];
		
			CountryCodeType.fromValue(cSender);
			CountryCodeType.fromValue(cReceiver);

			String dataProvider = p.getDataProvider().toUpperCase();
			if(commType.indexOf(dataProvider)<0)
				throw new Exception();
			
			Long.parseLong(messRefId);
		}
		catch(Exception e){
			Utils.logError(lg, e);
			throw new InvalidMessageRefIdException( Constants.STATUS_CODE_INVALID_MESSAGE_REF_ID, "MessageRefId is invalid!", this);
		}
		
		
		//return valid;
	}
}
